package impl::bscu

public

with common;
with platform;
with Base_Types;
with EMV2;
with ARP4761;

-- This is the implementation of the BSCU of the system
-- The BSCU contains two subsystems.
-- Each BSCU subsystem has the following interfaces:
--    1. Power
--    2. Pedal
-- Then, each BSCU subsystem has the following subcomponents:
--    1. A Command function that produces data from the pedal values.
--    2. A monitor function that indicates if the values are valid
--       or not.
-- The main BSCU receives data and power and forwards it
-- to each subsystem.
-- Also, the BSCU contains a Select_Alternate output data
-- that indicates wheter we should use the first subsystem
-- (Select_Alternate == false) or if the second (backup)
-- subsystem would be used (Select_Alternate == true).



-- The command system if part of each bscu subsystem.
-- It produces data from the brake pedal value.
-- This component is an error sink for the error side
-- and may fail from power-related error
-- and service-related error (no pedal).
process command
features
	brake : out data port common::command.brake;
	skid  : out data port common::command.skid;
	pedalvalue : in data port common::command.pedal;
end command;
 
process implementation command.i
annex EMV2 {**
	use types     WBSImplementationErrorLib;
	use behavior  error_library::simple;

	
	error propagations
		pedalvalue 		: in propagation {NoService};
		brake			: out propagation{NoValue};
		skid			: out propagation{NoValue};
		processor 		: in propagation {SoftwareFailure,HardwareFailure};
	flows
		nopedal 		: error sink pedalvalue{NoService};
		noskid			: error source skid{NoValue};
		nobrake			: error source brake{NoValue};
		platformerr		: error sink processor{SoftwareFailure,HardwareFailure};
	end propagations;
	
	component error behavior
	transitions
		terrfrompedal 		: Operational -[pedalvalue{NoService}]-> Failed;
		terrfromplatformsoft : Operational -[processor{SoftwareFailure}]-> Failed;
		terrfromplatformhard : Operational -[processor{HardwareFailure}]-> Failed;
	propagations
	    --  Here, we can imply that the NoService error from pedalvalue
	    --  is transformed into a NoValue on brake and skid features.
	    --  So, basically, this should be shown in the FMEA/FaultImpact
	    --  report. So, the report should show the error flows
	    --  pedals/NoService -> commands/brake/skid/NoValue -> monitor/NoValue -> selector/NoValue 
		p1 : Failed -[]-> brake{NoValue};
		p2 : Failed -[]-> skid{NoValue};
	end component;
**};
end command.i;


--  The monitor component receive the values
--  (brake and skid values) from the command system
--  and check if the system is valid or not. We have
--  one monitor for each BSCU.
--  The monitor may fail if he has no power.
process monitor
features
	brake : in data port common::command.brake;
	skid  : in data port common::command.skid;
	valid : out data port Base_Types::Boolean;
end monitor;

process implementation monitor.i
annex EMV2 {**
	use types     WBSImplementationErrorLib;
	use behavior  error_library::simple;
	
	error propagations
		processor : in propagation {SoftwareFailure,HardwareFailure};
		brake     : in propagation {NoValue};
		skid      : in propagation {NoValue};
		valid     : out propagation {NoValue};
	flows
		fsoft : error sink processor{SoftwareFailure,HardwareFailure};
		val   : error source valid{NoValue};
		bsink : error sink brake{NoValue};
		ssink : error sink skid{NoValue};
	end propagations;
	
	component error behavior
	events
		InvalidReport : error event;
	transitions
		terrinvalidreport    : Operational -[InvalidReport]-> Failed;
		noskid               : Operational -[skid{NoValue}]-> Failed;
		nobrake              : Operational -[brake{NoValue}]-> Failed;
		terrfromplatformsoft : Operational -[processor{SoftwareFailure}]-> Failed;
		terrfromplatformhard : Operational -[processor{HardwareFailure}]-> Failed;
	propagations
		p1 : Failed -[]-> valid{NoValue};
	end component;
	properties
		EMV2::severity => ARP4761::Minor applies to InvalidReport;
		EMV2::likelihood => ARP4761::Probable applies to InvalidReport;
		EMV2::hazards => 
			([	crossreference => "TBD";
				failure => "Invalid Report from BSCU Monitor";
				phases => ("TBD");
				description => "Report from a Monitor that causes an invalid switch to the alternate mode";
				comment => "Minor Hazard";
			])
			applies to InvalidReport;
**};
end monitor.i;


system bscu_subsystem
features
	pwr      : requires bus access common::power.generic;
	pedal    : in data port common::command.pedal;
	cmd_skid : out data port common::command.skid;
	cmd_brk  : out data port common::command.brake;
	valid    : out data port Base_Types::Boolean; 
end bscu_subsystem;

system implementation bscu_subsystem.generic
subcomponents
	mon   		: process monitor.i;
	cmd   		: process command.i;
connections
	pedaltocmd    : port pedal     -> cmd.pedalvalue;
	brakecmd      : port cmd.brake -> mon.brake;
	brakecmd_ext  : port cmd.brake -> cmd_brk;
	skidcmd_ext   : port cmd.skid  -> cmd_skid;
	skidcmd       : port cmd.skid  -> mon.skid;
	isvalid       : port mon.valid -> valid;
annex EMV2 {**
	use types     WBSImplementationErrorLib;
	use behavior  error_library::simple;
	
	error propagations
		pwr       : in propagation {NoPower};
		valid     : out propagation {NoValue};
	flows
	    nopwr   : error path pwr{NoPower} -> valid{NoValue};
	end propagations;
	
	component error behavior
	transitions
		t1 : Operational -[pwr{NoPower}]-> Failed;
	propagations
		p1 : Failed -[]-> valid{NoValue};
	end component;
	
	composite error behavior
	states
		[mon.failed or cmd.failed]-> Failed;
		[mon.operational and cmd.operational]-> Operational;
	end composite;
	properties
		EMV2::hazards => 
		([	crossreference => "ARP4761 figure L4 page 215";
			failure => "Failure of the BSCU, either from the monitor, the command or both";
			phases => ("all");
			description => "Failure of a BSCU";
			comment => "Would be critical if two subsystem (primary and redundant) are deffective";
		])
		applies to Failed;
		EMV2::severity => ARP4761::Major applies to Failed;
		EMV2::likelihood => ARP4761::Probable applies to Failed;
		EMV2::OccurrenceDistribution => [ ProbabilityValue => 3.3e-5 ; Distribution => Fixed;] applies to Failed;
**};
end bscu_subsystem.generic;




--  The select alternate is a binary operator that produces
--  an output from two input. If the first input is true
--  the result is false. Otherwise, the result is true. 
system select_alternate
features
	input1 : in data port Base_Types::Boolean;
	input2 : in data port Base_Types::Boolean;
	result : out data port Base_Types::Boolean;
annex EMV2 {**
	use types WBSImplementationErrorLib;
	use behavior WBSImplementationErrorLib::Twostate;
	
	error propagations
		input1 : in propagation {NoValue};
		input2 : in propagation {NoValue};
		result : out propagation{NoValue};
	flows
		f1 : error source result{NoValue};
		f2 : error sink input1{NoValue};
		f3 : error sink input2{NoValue};
	end propagations;  

--
--  We consider that the component may have an inconsistent
--  behavior and select the alternate source where there is
--  no reason for that. We capture that using a single
--  event called InternalError.
--	
	component error behavior
	events
		InternalError : error event;
	transitions
		t1 : Operational -[InternalError]-> Failed;
		--  If we do not have any value from each monitor,
		--  we are no longer able to send a valid data.
		t2 : Operational -[input1{NoValue} and input2{NoValue}]-> Failed; 
	propagations
		p1 : Failed -[]-> result{NoValue};
	end component;
	
	properties
		-- EMV2::OccurrenceDistribution => [ ProbabilityValue => 1.30e-5 ; Distribution => Fixed;] applies to InternalError;
		EMV2::OccurrenceDistribution => [ ProbabilityValue => 3.6e-6 ; Distribution => Poisson;] applies to InternalError;
	
		EMV2::severity => ARP4761::Hazardous applies to InternalError;
		EMV2::likelihood => ARP4761::ExtremelyImprobable applies to InternalError;
		EMV2::hazards => 
			([	crossreference => "ARP4761 figure L4 page 215";
				failure => "";
				phases => ("all");
				description => "BSCU validity monitor incorrectly report a Failure causing switch to alternate";
				comment => "";
			])
			applies to InternalError;
**};
end select_alternate;


system bscu
features
	pwr1              : requires bus access common::power.generic;
	pwr2              : requires bus access common::power.generic;
	pedal1            : in data port common::command.pedal;
	pedal2            : in data port common::command.pedal;
	Select_Alternate  : out data port Base_Types::Boolean;
	cmd_nor           : out data port common::command.skid; 
	cmd_alt           : out data port common::command.skid; 
annex EMV2 {**
	use types WBSImplementationErrorLib;
	
	
	error propagations
		pedal1 : in propagation {NoService};
		pedal2 : in propagation {NoService};
		pwr1   : in propagation {NoPower};
		pwr2   : in propagation {NoPower};
	end propagations;
**};
end bscu;

system implementation bscu.basic
annex EMV2 {**
	use types WBSImplementationErrorLib;
	use behavior error_library::bscu;
	
	error propagations
	flows
		es1   : error sink pwr1{NoPower};
		es2   : error sink pwr2{NoPower};
	end propagations;
	
	component error behavior
	transitions
		nopower1 : Operational -[pwr1{NoPower}]-> Failed;
		nopower2 : Operational -[pwr2{NoPower}]-> Failed;
	end component;
	
	
	properties
			EMV2::hazards => 
		([	crossreference => "TBD";
			failure => "No power line";
			phases => ("TBD");
			description => "Permanent failure of power supply source";
			comment => "Would be critical if both power supplies are lost";
		])
		applies to pwr1, pwr2;
**};
end bscu.basic;


system implementation bscu.generic
subcomponents
	sub1    : system bscu_subsystem.generic;
	sub2    : system bscu_subsystem.generic;
	select  : system select_alternate;

connections
	sub1pwr        : bus access pwr1 <-> sub1.pwr;
	sub2pwr        : bus access pwr2 <-> sub2.pwr;
	sub1pedal      : port pedal1 <-> sub1.pedal;
	sub2pedal      : port pedal2 <-> sub2.pedal;
	selectvalid1   : port sub1.valid -> select.input1;
	selectvalid2   : port sub2.valid -> select.input2;
	selectvalidout : port select.result -> Select_Alternate;
	sub1skid       : port sub1.cmd_skid -> cmd_nor;
	sub2skid       : port sub2.cmd_skid -> cmd_alt;
annex EMV2 {**
	use types WBSImplementationErrorLib;
	use behavior error_library::bscu;
	
	
	component error behavior
	transitions
		nopower : Operational -[pwr1{NoPower} and pwr2{NoPower}]-> Failed;
	end component;
	
	composite error behavior
	states
		[sub1.Failed and sub2.Failed]-> Failed;
		[sub1.Failed and sub2.Operational]-> Alternate;
		[sub1.Operational and sub2.Operational and select.Failed]-> Alternate;
		[sub1.Operational and sub2.Operational and select.Operational]->Operational;
	end composite;
	
	properties
			EMV2::hazards => 
		([	crossreference => "TBD";
			failure => "No power line";
			phases => ("TBD");
			description => "Permanent failure of power supply source";
			comment => "Would be critical if both power supplies are lost";
		])
		applies to pwr1, pwr2;
**};
end bscu.generic;



system implementation bscu.federated extends bscu.generic
subcomponents
	platform : system platform::platform.federated;
properties
	Actual_Processor_Binding => (reference (platform.cpu1)) applies to sub1.cmd;
	Actual_Processor_Binding => (reference (platform.cpu1)) applies to sub1.mon;
	Actual_Processor_Binding => (reference (platform.cpu2)) applies to sub2.cmd;
	Actual_Processor_Binding => (reference (platform.cpu2)) applies to sub2.mon;	
end bscu.federated;



system implementation bscu.ima extends bscu.generic
subcomponents
	platform : system platform::platform.ima;
properties
	Actual_Processor_Binding => (reference (platform.cpu.partition1)) applies to sub1.cmd;
	Actual_Processor_Binding => (reference (platform.cpu.partition2)) applies to sub1.mon;
	Actual_Processor_Binding => (reference (platform.cpu.partition3)) applies to sub2.cmd;
	Actual_Processor_Binding => (reference (platform.cpu.partition4)) applies to sub2.mon;	
end bscu.ima;


end impl::bscu;