package redundant2
public

data mydata
end mydata;

-- cpu as example with error source as leaf of bindings
processor cpu
annex EMV2 {**
	use types errorlibrary;
	error propagations
		bindings: out propagation {ServiceError};
	flows
		cpufail : error source  bindings{ServiceError};
	end propagations;
**};
end cpu;


-- memory as example with error source as leaf of bindings
memory mem
annex EMV2 {**
	use types errorlibrary;
	error propagations
		bindings: out propagation {ServiceError};
	flows
		memfail : error source  bindings{ServiceError};
	end propagations;
**};
end mem;


-- bus as example with error source as leaf of bindings
bus transport
annex EMV2 {**
	use types errorlibrary;
	error propagations
		bindings: out propagation {ServiceError};
	flows
		busfail : error source  bindings{ServiceError};
	end propagations;
**};
end transport;

-- sensor as source of two errors
device sensor
features
	valueout : out data port mydata;
annex EMV2{**
 	use types ErrorLibrary;
 	use behavior ErrorLibrary::FailStop;
 	error propagations
 		valueout : out propagation {LateDelivery, OutOfRange};
 	flows
 		ef0 : error source valueout{LateDelivery};
 		ef1 : error source valueout{OutOfRange};
 	end propagations;
 **};
end sensor;

-- actuator passes through errors and maps them into service omission
device actuator
features
	valuein : in data port mydata;
	actionout : out feature ;
annex EMV2{**
 	use types ErrorLibrary;
 	use behavior ErrorLibrary::FailStop;
 	error propagations
 		valuein : in propagation {ItemOmission,ValueCorruption,InconsistentValue};
 		actionout: out propagation {ServiceOmission};
 	flows
 		ef1 : error path valuein{ItemOmission,ValueCorruption,InconsistentValue} -> actionout{ServiceOmission};
 	end propagations;
 **};
end actuator;

-- actuator.failstate elaborates error behavior with state machine
-- incoming errors are elaborated into a transition to failstop.
-- failstop propagates as service omission
device implementation actuator.failstate
annex EMV2{**
 	use types ErrorLibrary;
 	use behavior ErrorLibrary::FailStop;
 	component error behavior
 	transitions
 		t0 : Operational -[ valuein{ItemOmission}]-> FailStop;
 		t1 : Operational -[ valuein{ValueCorruption}]-> FailStop;
 		t2 : Operational -[ valuein{InconsistentValue}]-> FailStop;
 	propagations
 		prop1: FailStop-[]-> actionout{ServiceOmission};
 	end component;
 **};
	
end actuator.failstate;


-- internal error events result in degraded or failstop
-- incoming propagation on both inputs results in item omission
thread voter_thr
features
	valuein1 : in data port mydata;
	valuein2 : in data port mydata;
	valueout : out data port mydata;
annex EMV2{**
 	use types ErrorLibrary;
 	-- we use our own three state EBSM.
 	-- a computeerror error event leads to Degraded, which as error source generates InconsistentValue
 	-- a Failure error event leads to FailStop, which propagates ItemOmission
 	use behavior FTErrorLibrary::DegradedFailStop;
 	error propagations
 		valuein1 : in propagation {LateDelivery, OutOfRange};
 		valuein2 : in propagation {LateDelivery, OutOfRange};
 		valueout : out propagation {ItemOmission,ValueCorruption,InconsistentValue};
 		processor: in propagation {ServiceError}; 
 		memory   : in propagation {ServiceError};
 	flows
 		ef1 : error path valuein1{LateDelivery,OutOfRange} -> valueout{ItemOmission};
 		ef2 : error path valuein2{LateDelivery,OutOfRange} -> valueout{ItemOmission};
 		-- ef3 and ef4 are to be used in FTA since there is no refinement in the component error behavior
 		ef3 : error path processor{ServiceError} -> valueout{ItemOmission};
 		ef4 : error path memory{ServiceError} -> valueout{ValueCorruption};
 		-- the error source is refined by prop2
 		ef5 : error source valueout{InconsistentValue};
 	end propagations;
 	component error behavior
 	propagations
 	prop1: Operational -[valuein1{LateDelivery, OutOfRange} and valuein2{LateDelivery, OutOfRange}]-> valueout{ItemOmission};
 	prop2: Degraded -[]-> valueout{InconsistentValue};
 	prop3: FailStop -[]-> valueout{ItemOmission};
 	end component;
 **};
end voter_thr;

thread voter_thr1
	-- in this case out of range on both results in out of range
	-- similarly late delivery on both results in late delivery
features
                valuein1 : in data port mydata;
                valuein2 : in data port mydata;
                valueout : out data port mydata;
annex EMV2{**
 use types ErrorLibrary, FTerrorlibrary;
 use behavior ErrorLibrary::FailStop;
 error propagations
   valuein1 : in propagation {LateDelivery, OutOfRange};
   valuein2 : in propagation {LateDelivery, OutOfRange};
   valueout : out propagation {ItemOmission,ValueCorruption,InconsistentValue, LateDelivery};
   processor: in propagation {ServiceError}; 
   memory   : in propagation {ServiceError};
 flows
   ef1 : error path valuein1{LateDelivery,OutOfRange} -> valueout{ItemOmission};
   ef2 : error path valuein2{LateDelivery,OutOfRange} -> valueout{ItemOmission};
   -- since there are no out propagation rules in the component error behavior
   -- the next three flows determine the FTA additions
   -- There is no need for an out propagation rule since it is an unconditional single propagation mapping.
   -- Each becomes an OR element in the FTA 
   ef3 : error path processor{ServiceError} -> valueout{ItemOmission};
   ef4 : error path memory{ServiceError} -> valueout{ValueCorruption};
   ef5 : error source valueout{InconsistentValue};
   -- ef5 indicates that voter_thr is an error source, i.e., there is some voter internal error event as the soruce.
   -- the user behavior declaration associates an error behavior state machine (EBSM) with a Failure error event.
   -- If it were a three state EBSM we would not know which state and related error event is the source.
   -- To address this we can do one of two things:
   -- 1) connect the EBSM to the error source via component error behavior declaration as done in voter_thr (above)
   -- 2) add a when clause to the error source declaration.
   --    when {ComputationError}  : the source is an implicit error event of type ComputationError 
   --    when FailStop : identifies the state whose incoming transition error event trigger is the source.
 end propagations;
 component error behavior
 propagations
 -- note these propagation rules do not map valuein1{LateDelivery} and valuein2{OutOfRange}
 -- in voter_thr the combinations are specified in the rule.
    p1 : all -[ valuein1{LateDelivery} and valuein2{LateDelivery}]-> valueout{LateDelivery};
    p2 : all -[ valuein1{OutOfRange} and valuein2{OutOfRange}]-> valueout{OutOfRange};
 end component;
**};
end voter_thr1;


process voter
features
	valuein1 : in data port mydata;
	valuein2 : in data port mydata;
	valueout : out data port mydata;
	-- No more warning if voter does not include an EMV2 subclause
end voter;

process implementation voter.i
subcomponents
	thr : thread voter_thr;
connections
	c0 : port valuein1 -> thr.valuein1;
	c1 : port valuein2 -> thr.valuein2;
	c2 : port thr.valueout -> valueout;
end voter.i;

process implementation voter.i1
subcomponents
	thr : thread voter_thr1;
connections
	c0 : port valuein1 -> thr.valuein1;
	c1 : port valuein2 -> thr.valuein2;
	c2 : port thr.valueout -> valueout;
end voter.i1;

system main2
	features
		externaleffect: out feature;
		annex EMV2 {**
			use types ErrorLibrary;
			error propagations
			externaleffect: out propagation {ServiceOmission};
			end propagations;
		**};
end main2;

-- in this configuration we map the actuator fail state into the top system fail state.
-- This requires that all incoming propagations result in a transition of the actuator to the fail state.
-- This error behavior is specified in actuator.failstate.
system implementation main2.composite
subcomponents
	sensor1 : device sensor;
	sensor2 : device sensor;
	voter   : process voter.i;
	actuator : device actuator.failstate;
	
	cpu : processor cpu;
	mem : memory mem;
	
	mybus : bus transport;
connections
	c0 : port sensor1.valueout -> voter.valuein1;
	c1 : port sensor2.valueout -> voter.valuein2;
	c2 : port voter.valueout -> actuator.valuein;
properties
	actual_processor_binding => (reference (cpu)) applies to voter;
	actual_memory_binding => (reference (mem)) applies to voter;
	Actual_Connection_Binding => (reference (mybus)) applies to c0;
	Actual_Connection_Binding => (reference (mybus)) applies to c1;
	Actual_Connection_Binding => (reference (mybus)) applies to c2;
annex EMV2{**
 	use types ErrorLibrary;
 	use behavior ErrorLibrary::FailStop;
 	composite error behavior 
 	states
 		[ actuator.failstop ]-> FailStop;
 	end composite;
 **};
end main2.composite;

system implementation main2.compositesametype
subcomponents
	sensor1 : device sensor;
	sensor2 : device sensor;
	voter   : process voter.i1;
	actuator : device actuator.failstate;
	
	cpu : processor cpu;
	mem : memory mem;
	
	mybus : bus transport;
connections
	c0 : port sensor1.valueout -> voter.valuein1;
	c1 : port sensor2.valueout -> voter.valuein2;
	c2 : port voter.valueout -> actuator.valuein;
properties
	actual_processor_binding => (reference (cpu)) applies to voter;
	actual_memory_binding => (reference (mem)) applies to voter;
	Actual_Connection_Binding => (reference (mybus)) applies to c0;
	Actual_Connection_Binding => (reference (mybus)) applies to c1;
	Actual_Connection_Binding => (reference (mybus)) applies to c2;
annex EMV2{**
 	use types ErrorLibrary;
 	use behavior ErrorLibrary::FailStop;
 	component error behavior
 	transitions
 	Operational -[actuator.actionout{ServiceOmission}]-> FailStop;
 	end component;
 	composite error behavior 
 	states
 		[ actuator.failstop ]-> FailStop;
 	end composite;
 **};
end main2.compositesametype;

-- In this configuration we map the outgoing propagation from the actuator to the outgoing propagation of main2.
-- Voter maps any error on both incoming (AND) to omission
system implementation main2.transition
subcomponents
	sensor1 : device sensor;
	sensor2 : device sensor;
	voter   : process voter.i;
	actuator : device actuator;
	
	cpu : processor cpu;
	mem : memory mem;
	
	mybus : bus transport;
connections
	c0 : port sensor1.valueout -> voter.valuein1;
	c1 : port sensor2.valueout -> voter.valuein2;
	c2 : port voter.valueout -> actuator.valuein;
properties
	actual_processor_binding => (reference (cpu)) applies to voter;
	actual_memory_binding => (reference (mem)) applies to voter;
	Actual_Connection_Binding => (reference (mybus)) applies to c0;
	Actual_Connection_Binding => (reference (mybus)) applies to c1;
	Actual_Connection_Binding => (reference (mybus)) applies to c2;
annex EMV2{**
 	use types ErrorLibrary;
 	use behavior ErrorLibrary::FailStop;
	component error behavior
		propagations
		all -[actuator.actionout{ServiceOmission}]-> externaleffect{ServiceOmission};
	end component;
 **};
end main2.transition;

end redundant2;
